/*
* Semantic clone benchmark
*  Source code are extracted from Stack Overflow
*  Stack overflow Question #:43803429
*  Stack Overflow answer #:43803734
*  And Stack Overflow answer#:43804477
*/
int QueueDeleteNext (Queue *myQueue, char value) {
    Node *current_node, *previous_node;
    previous_node = NULL;
    for (current_node = myQueue->front; current_node != NULL; previous_node = current_node, current_node = current_node->next) {
        if (current_node->gender == value) {
            if (previous_node == NULL) {
                myQueue->front = myQueue->back = NULL;
            }
            else {
                previous_node->next = current_node->next;
                if (previous_node->next == NULL) {
                    myQueue->back = previous_node;
                }
            }
            free (current_node);
            return 1;
        }
    }
    return 0;
}

int QueueDeleteNext (struct Queue *q, char value) {
    struct Node *prev = NULL;
    struct Node *curr = q->front;
    int count = 0;
    while (curr) {
        if (curr->gender == value) {
            struct Node *nn = curr;
            if (prev == NULL) {
                q->front = curr->next;
            }
            else {
                prev->next = curr->next;
            }
            if (curr == q->back)
                q->back = prev;
            curr = curr->next;
            free (nn);
            count++;
        }
        else {
            prev = curr;
            curr = curr->next;
        }
    }
    return count;
}

